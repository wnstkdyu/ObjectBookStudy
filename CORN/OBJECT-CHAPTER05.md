## CHAPTER 05 - 책임 할당하기

- p133
  - 데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 데이터가 아닌 책임에 초점을 맞추는 것이다. 
  - 책임에 초점을 맞춰서 설계할 때 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것.
  - GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시.

- p134
  - 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위한 두 가지 원칙 
    1. 데이터보다 행동을 먼저 결정
    2. 협력이라는 문맥 안에서 책임을 결정
  - 객체에게 중요한 것은 데이터가 아니라 외부에게 제공하는 행동
    - 데이터는 객체가 책임을 수행하는데 필요한 재료일 뿐
    - 책임을 먼저 결정한 후에 객체의 상태를 결정
  - 객체지향 설계에서 가장 중요한 것은 적절한 객체에게 적절한 책임을 할당하는 능력
- p135
  - 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다. 
  - 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.
- p136
  - 객체에게 적절한 책임을 할당하기 위해서는 협력이라는 문맥을 고려해야 한다. 
  - 책임 중심의 설계에서는 협력이라는 문맥 안에서 객체가 수행할 책임에 초점을 맞춘다. 
  - 책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것
- p137
  - 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 도메인 개념
- p138
  - 도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 돼야 한다. 
  - 책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공하는 기능을 애플리케이션의 책임으로 생각하는 것.
  - 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 한다. 
- p139
  - 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것
    - INFORMATION EXPERT(정보 전문가) 패턴 : 책임을 수행하는데 필요한 정보를 가지고 있는 객체에게 할당하라
  - 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력 있고, 이해하기 쉬워진다. 따라서 높은 응집도가 가능하다. 결과적으로 결합도가 낮아져서 간결하고 유지보수가 쉬운 시스템을 구축할 수 있다.
- p142
  -  INFORMATION EXPERT 패턴은 객체랑 상태와 행동을 함께 가지는 단위라는 객체지향의 가장 기본적인 원리를 책임 할당의 관점에서 표현한다. 
- p143
  - 높은 응집도와 낮은 결합도는 객체에게 책임을 할당할 때 항상 고려해야 하는 기본 원리다. 
  - LOW COUPLING 패턴
    - 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있는 방법 - 낮은 결합도 
- p144
  - HIGH COHESION
    - 복잡성을 관리할 수 있는 수준으로 유지하는 방법 - 높은 응집도
  - LOW COUPLING, HIGH COHESION 패턴은 책임과 협력의 품질의 중요한 평가 기준
  - CREATOR 패턴은 객체를 생성할 책임을 어떤 객체에 할당할지에 대한 지침을 제공
- p145
  - CREATOR 패턴은 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다. 
- p152
  - 응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미
    - 변경의 이유에 따라 클래스를 분리해야 한다.
  - 설계를 개선하는 작업은 변경의 이유가 하나 이상의 클래스를 찾는 것으로부터 시작하는 것이 좋다.
  - 변경의 이유를 파악할 수 있는 방법
    1. 인스턴수 변수가 초기화되는 시점
       - 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화
       - 응집도가 낮은 크래스는 객체의 속성 중 일부만 초기화
       - 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
    2. 메소드들이 인스턴스 변수를 사용하는 방식
       1. 메소드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다. 
       2. 속성 그룹과 해당 그룹에 접근하는 메소드 그룹을 기준으로 코드를 분리해야 한다. 
- p153
  - 응집도를 판단할 수 있는 세 가지 방법
    - 하나 이상의 이유로 변경 :arrow_right: 응집도가 낮은 것.
      - 변경의 이유를 기즌으로 클래스를 분리
    - 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화 :arrow_right: 응집도가 낮은 것
      - 초기화되는 속성의 그룹을 기준으로 클래스를 분리
    - 메소드 그룹이 속성 그룹을 사용하는지 여부로 나뉨 :arrow_right: 응집도가 낮은 것 
      - 그룹을 기준으로 클래스를 분리
  - 타입 분리하기 
    - `DiscountCondition`의 가장 큰 문제는 두 개의 독립적인 타입이 하나의 클래스 안에 공존하고 있다는 점.
- p156
  - 다형성을 통해 분리하기
  - 역할은 협력 안에서 대제 가능성을 의미 
- p158
  - POLYMORPHISM 패턴
    - 객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가? 
      - 타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당.
- p159
  - 변경을 캡슐화하도록 책임을 할당하는 것을 PROTECTED VARIATIONS 패턴이라고 부른다. 
  - PROTECTED VARIATIONS 패턴
    - 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
    - 책임 할당의 관점에서 캡슐화를 설명한 것.
    - 캡슐화해야 하는 것은 변경이다. 
  - 클래스를 변경헤 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법
- p163
  - 객체에게 중요한 것은 상태가 아니라 행동. 객체지향의 설계의 기본은 책임과 협력에 초점을 맞추는 것.
  - 설계를 주도하는 것은 변경
  - 변경에 대비할 수 있는 두 가지 방법
    1. 코드를 이해하고 수정하기 쉽도록 단순하게 설계하는 것.
    2. 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것.
- p166
  - 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 리팩터링이라고 부른다.
- p168
  - 긴 메소드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 미친다.
  - 응집도가 낮은 메소드는 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분
  - 주석을 추가하는 대신 메소드를 작게 분해해서 각 메소드의 응집도를 높여라.
- p169
  - 객체로 책임을 분배할 때 가장 먼저 할 일은 메소드를 응집도 있는 수준으로 분해하는 것이다. 작고 응집도가 낮은 메소드로 분리하면 각 메소드를 적절한 클래스로 이동하기가 더 수월해진다.
- p171
  - 일반적으로 명확성의 가치가 클래스의 길이보다 더 중요
  - 코드를 작은 메소드들로 분해하면 전체적인 흐름을 이해하기도 쉬워진다. 
  - 작고 명확하며, 한 가지 일에 집중하는 응집도 높은 메소드는 변경 가능한 설계를 이끌어 내는 기반이 된다. 
- p172
  - 어떤 메소드를 어떤 클래스로 이동시켜야 할까?
    - 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길. 
    - 메소드가 사용하는 데이터를 저장하고 있는 클래스로 메소드를 이동 
- p174
  - 데이터를 사용하는 메소드를 메이터를 가진 클래스로 이동시키고 나면 캡슐화와 높은 응집도, 낮은 결합도를 가지는 설계를 얻게 된다.
  - 책임 주도 설계 방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩터링하더라도 유사한 결과를 얻을 수 있다.
  - 리팩터링하는 것이 더 훌륭한 결과물을 낳을 수도 있다.