# 일관성 있는 협력

유사한 기능은 유사한 방식으로 구현해야 한다. 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이므로 유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것이다.

### 설계에 일관성 부여하기

일관성 있는 설계를 만드는데에는 설계경험을 익히는것, 디자인 패턴을 학습하고 변경이라는 문맥안에서 적용해보는것 이 필요하다.

**협력을 일관성 있게 만들기 위한 기본 지침**

- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.

**조건 로직 대 객체 탐색**

객체지향에서 변경을 다루는 전통적인 방법은 조건 로직을 객체사이의 이동으로 바꾸는 것이다. (다형성)
객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.(메시지만 전달)

**캡슐화 다시 살펴보기**

설계에 변경을 강요하는 것이 무엇인지에 대해 고려하기보다는 재설계 없이 변경할 수 있는 것이 무엇인지 고려하라. 여기서의 초점은 많은 디자인 패턴의 주제인 변화하는 개념을 캡슐화하는 것이다.
소프트웨어 안에서 변할 수 있는 모든 개념을 감추는 것이다.

- 데이터 캡슐화 : Movie클래스의 인스턴스 변수 title의 가시성은 private이기 때문에 외부에서 직접 접근할 수 없다. 
- 메서드 캡슐화 : Discountpolicy클래스에서 정의돼 있는 getDiscountAmount 메서드의 가시성은 protected다. 클래스의 외부에서는 이 메서드에 직접 접근할 수 없고 클래스 내부와 서브클래스에서만 접근이 가능하다. 외부에 영향을 미치지 않고 메서드를 수정할 수 있다.
- 객체 캡슐화 : Movie 클래스는 DiscountPolicy타입의 인스턴스 변수 discountPolicy를 포함한다. 이 인스턴스 변수는 private 가시성을 가지기 때문에 Movie 와 DiscountPolicy사이의 관계를 변경하더라도 외부에는 영향을 미치지 않는다. 
  객체 사이의 관계를 캡슐화 == 합성
- 서브타입 캡슐화 : Movie는 DiscountPolicy에 대해서는 알고 있지만 DiscountPolicy의 서브클래스에 대해서는 알지 못한다. 하지만 실행시점에 협력할 수 있는데, DiscountPolicy와의 추상적인 관계가 서브클래스의 존재를 감추고 있기 때문이다. (다형성기반)

협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것이다.

서브타입 캡슐화와 객체 캡슐화를 적용하는 방법

- 변하는 부분을 분리해서 타입 계층을 만든다
  변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화한 후 변하는 부분들이 이 추상 클래스나 인터페이스를 상속받게 만든다. 변하는 부분은 변하지 않는 부분의 서브타입이 된다.
- 변하지 않는 부분의 일부로 타입 계층을 합성한다
  의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존하게 만든다. 이제 변하지 않는 부분은 변하는 부분의 구체적인 종류에 대해서는 알지 못할 것이다.

### 일관성 있는 기본 정책 구현하기

공통점은 변하지 않는 부분이고, 차이점은 변하는 부분이다.
변하지 않는 규칙으로부터 변하는 적용조건을 분리해야한다.

**변경 캡슐화하기**

규칙으로부터 적용조건을 분리해서 추상화한 후 시간대별, 요일별, 구간별 방식을 이 추상화의 서브타입으로 만든다. 이것이 서브타입 캡슐화다
그 후에 규칙이 적용조건을 표현하는 추상화를 합성 관계로 연결한다. 이것이 객체 캡슐화다.

**협력 패턴 설계하기**

추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 된다. 다시말해서 재사용 가능한 협력 패턴이 선명하게 드러나는 것이다.

**추상화 수준에서 협력 패턴 구현하기**

변하지 않는 요소와 추상적인 요소 만으로도 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다
변하는것과 변하지 않는것을 분리하고 변하는 것을 캡슐화한 코드는 오로지 변하지 않는 것과 추상화에 대한 의존성만으로도 전체적인 협력을 구현할 수 있다.

**구체적인 협력 구현하기**

FeeCondition 인터페이스를 실체화하는 클래스에 따라 기본 정책의 종류가 달라진다.
`func findTimeIntervals` 재사용?
일관성 있는 협력을 이해하고 나면 변하는 부분만 따로 떼어내어 독립적으로 이해하더라도 전체적인 구조를 쉽게 이해할 수 있다.
유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 가장 효과적인 방법이다.

**협력 패턴에 맞추기**

FixedFeeCondition을 추가하는것이 불편한 사실이지만, 개념적 무결성을 무너뜨리는 것보다는 약간의 부조화를 수용하는 편이 낫다.
현재의 설계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 것이 중요하다.

**패턴을 찾아라**

협력을 일관성 있게 만드는 과정은 유사한 기능을 구현하기 위해 반복적으로 적용할 수 있는 협력의 구조를 찾아가는 기나긴 여전이다. (유사한 변경을 수용할 수 있는 협력 패턴을 발견)
패턴 / 프레임워크