# 14장 정리

애플리케이션 개발을 하다 보면 유사한 요구사항을 반복적으로 추가하거나 수정하게 되는 경우가 있다. 이 때 객체들의 협력 구조가 서로 다른 패턴을 보일 경우 전체적인 설계의 일관성이 무너지고 코드를 이해하기 어려우며 버그가 발생할 위험성도 높아진다.

객체지향 패러다임의 장점은 설계를 재사용할 수 있다는 것이다. 재사용을 하기 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다. 특정한 문제를 일관적으로 해결하는 것은 유사한 기능을 구현하는 데 드는 시간 또한 줄일 뿐만 아니라 코드를 직관적으로 이해할 수 있게 된다.

## 1. 핸드폰 과금 시스템 변경하기

예시에서 나오는 코드 구현의 가장 큰 문제점은 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것이다. 다시 말해 개념적으로는 연견돼 있지만 구현 방식에 있어서는 완전히 제각각이라는 것이다.

비일관성은 두 가지 상황에서 발목을 잡는다.

- 새로운 구현을 추가해야 하는 경우
  - 비일관적인 설계를 한 경우 새로운 요구 사항을 적용할수록 코드 사이의 일관성이 점점 더 어긋나게 됨
- 기존의 구현을 이해해야하는 상황
  - 대부분의 사람들은 유사한 요구사항을 구현하는 코드는 유사한 방식으로 구현될 것이라고 예상
  - 하지만 유사한 요구사항이 서로 다른 방식으로 구현돼 있다면 요구사항이 유사하다는 사실 자체도 의심하게 됨
  - 결국 유사한 요구사항을 요구하는 서로 다른 구조의 코드는 코드 이해의 심리적인 장벽을 만들게 됨

객체 지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것뿐이므로 **유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것**이다.

## 2. 설계에 일관성 부여하기

일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것이다. 풍부한 설계 경험을 가진 사람은 어떤 변경이 중요한지, 그리고 그 변경을 어떻게 다뤄야 하는지에 대한 통찰력을 가지게 된다. 따라서 설계 경험이 풍부하면 풍부할수록 어떤 위치에서 일관성을 보장해야 하고 일관성을 제공하기 위해 어떤 방법을 사용해야 하는지를 직관적으로 결정할 수 있다.

두 번째 조언은 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해 보라는 것이다. 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿이기 때문에 빠른 시간 안에 전문가의 경험을 흡수할 수 있다.

협력을 일관성 있게 만들기 위해서는 다음과 같은 기본 지침을 따르는 것이 도움이 된다.

- 변하는 개념을 변하지 않는 개념으로부터 분리하라
- 변하는 개념을 캡슐화하라

> "바뀌는 부분을 따로 뽑아서 캡슐화한다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다."

### 조건 로직 대 객체 탐색

조건 로직을 통한 설계가 나쁜 이유는 **변경의 주기가 서로 다른 코드가 한 클래스에 뭉쳐있기 때문**이다. 또한 새로운 요구사항을 추가할 때 **기존 코드의 내부를 수정해야 하기 때문에 오류가 발생할 확률이 높아**진다.

객체지향에서 변경을 다루는 전통적인 방법은 **조건 로직을 객체 사이의 이동으로 바꾸는 것**이다.

다형성은 바로 이런 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법이다. `Movie` 는 할인 정책이 어떤 종류인지 판단하지 않고 단지 할인 정책에 자신의 요청을 담은 메시지를 전달할 뿐이다.

조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스들로 분리해야 한다. **클래스를 분리하기 위한 가장 중요한 기준은 변경의 이유와 주기**다. 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야 한다(단일 책임 원칙).

큰 메서드 안에 뭉쳐있던 조건 로직들을 변경의 압력에 맞춰 작은 클래스들로 분리하고 나면 인스턴스들 사이의 협력 패턴에 일관성을 부여하기가 더 쉬워진다. **유사한 행동을 하는 작은 클래스들이 "역할"이라는 추상화로 묶이게 되고 역할 사이에서 이뤄지는 협력 방식이 전체 설계의 일관성을 유지할 수 있게 이끌어주기 때문**이다.

핵심은 훌륭한 추상화를 찾아 추상화에 의존하도록 만드는 것이다. 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다.

### 캡슐화 다시 살펴보기

캡슐화를 간단히 한 문장으로 표현하면 다음과 같다.

- "캡슐화란 변하는 어떤 것이든 감추는 것이다."

캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것이다. 자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 한다.

캡슐화의 종류에는 다음과 같은 것들이 존재한다.

- 데이터 캡슐화
  - 인스턴스 변수에 대한 가시성을 의미
- 메서드 캡슐화
  - 클래스 내부 행동을 캡슐화
- 객체 캡슐화
  - 객체와 객체 사이의 관계를 캡슐화하는 것을 의미하며 **"합성"**을 의미
- 서브타입 캡슐화
  - `DiscountPolicy` 는 런타임에 실제 구현 클래스인 `AmountDiscountPolicy`와 `PercentDiscountPolicy`로 대체되며 실제 협력을 하게 된다. 하지만 `Movie` 는 `DiscountPolicy` 의 서브 타입의 종류를 모르게 된다.
  - 따라서 서브 타입의 종류를 캡슐화하는 것이며 이는 다형성의 기반이 된다.

일반적으로 데이터 캡슐화와 메서드 캡슐화는 개별 객체에 대한 변경을 관리하기 위해 사용하고 객체 캡슐화와 서브타입 캡슐화는 협력에 참여하는 객체들의 관계에 대한 변경을 관리하기 위해 사용한다.

변경을 캡슐화할 수 있는 다양한 방법이 존재하지만 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것이다. **서브타입 캡슐화는 인터페이스 상속을 사용하고 객체 캡슐화는 합성을 사용**한다.

서브타입 캡슐화와 객체 캡슐화를 적용하는 방법은 다음과 같다.

- 변하는 부분을 분리해서 타입 계층을 만든다.
  - 변하는 부분들의 공통적인 행동을 추상 클래스나 인터페이스로 추상화하고 변하는 부분들이 이 추상 클래스나 인터페이스를 상속받게 만듦
  - 이제 변하는 부분은 변하지 않는 부분의 서브타입이 됨
- 변하지 않는 부분의 일부로 타입 계층을 합성한다.
  - 앞에서 구현한 타입 계층을 변하지 않는 부분에 합성한다. 이 때 의존성 주입과 같이 결합도를 느슨하게 유지할 수 있는 방법을 이용해 오직 추상화에만 의존하게 만든다.

## 3. 일관성 있는 기본 정책 구현하기

변하지 않는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 적절히 추상화하고 나면 변하는 부분을 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기할 수 있다. 추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 한다. 다시 말해서 **재사용 가능한 협력 패턴이 선명하게 드러나는 것**이다.

추상적인 요소만으로도 전체적인 협력 구조를 설명할 수 있게 되는 것, 이것이 핵심이다. 이제는 변하는 부분을 구현하기만 하면 된다.

구현 시에도 오직 변하는 부분만 구현하면 되기 때문에 원하는 기능을 쉽게 완성할 수 있다. 따라서 코드의 재사용성이 향상되고 테스트해야 하는 코드의 양이 감소한다. **기능을 추가할 때 따라야 하는 구조를 강제할 수 있기 때문에 기능을 추가하거나 변경할 때도 설계의 일관성이 무너지지 않는다.**

일관성 있는 협력은 개발자에게 확장 포인트를 강제하기 때문에 정해진 구조를 우회하기 어렵게 만든다. 개발자는 코드의 형태로 주어진 제약 안에 머물러야 하지만 작은 문제에 집중할 수 있는 자유를 얻는다.

### 지속적으로 개선하라

처음에는 일관성을 유지하는 것처럼 보이던 협력 패턴이 시간이 흐르면서 새로운 요구사항이 추가되는 과정에서 일관성의 벽에 조금씩 금이 가는 경우를 자주 보게 된다. 협력을 설계하는 초기 단계에서 모든 요구사항을 미리 예상할 수 없기 때문에 이는 자연스러운 현상이며 오히려 설계를 진화시킬 수 있는 좋은 신호이다.

만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링하자. 요구사항의 변경에 따라 협력 역시 지속적으로 개선해야 한다.

