# 13장 정리

상속에 대한 불신과 오해를 풀기 위해서는 상속이 두 가지 용도로 사용된다는 사실을 이해하는 것이 중요하다.

상속의 첫 번째 용도은 **타입 계층**을 구현하는 것이다. 타입 계층의 관점에서 부모 클래스는 자식 클래스의 **일반화(generalization)** 이고 자식 클래스는 부모 클래스의 **특수화(specialization)** 이다.

상속의 두 번째 용도는 **코드 재사용** 이다. 간단한 선언만으로 부모의 코드를 재사용할 수 있어 점진적으로 애플리케이션의 기능을 확장하는 데에 용이하지만 부모와 자식이 강하게 결합되어 변경에 취약한 코드를 얻게 될 확률이 높다.

상속의 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이다. 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 **행동** 을 기반으로 타입 계층을 구성해야 한다. 이를 통해 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.

상속은 이러한 타입 계층 구현을 쉽게 해주는 데에 의의가 있으며 이번 장에서는 올바른 타입 계층을 구성하는 원칙을 살펴본다.

## 1. 타입

객체 지향 프로그래밍에서의 타입의 의미를 이해하려면 먼저 프로그래밍 언어 관점에서의 타입과 개념 관점에서의 타입을 살펴봐야 한다.

### 개념 관점의 타입

개념 관점에서 타입이란 **우리가 인지하는 세상의 사물의 종류를 의미**한다. 타입은 우리가 인식하는 개념이나 아이디어를 분류하기 위해 사용되며 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 **인스턴스(instance)**라고 부른다. 또한 일반적으로 타입의 인스턴스를 **객체**라고 부른다.

이러한 설명을 통해 타입이 심볼, 내연, 외연의 세 가지 요소로 구성된다는 것을 알 수 있다.

- **심볼(symbol)**
  - 타입에 이름을 붙인 것
- **내연(intension)**
  - 타입의 정의로서 **타입이 속하는 객체들이 가지는 공통적인 속성이나 행동**을 가리킴
  - '프로그래밍 언어'의 정의인 '컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합'이 바로 내연에 속하는 것
  - 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연은 구성
- **외연(extension)**
  - 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입

프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다. 비트 자체에는 아무런 의미가 없지만 여기에 담긴 데이터를 어떻게 다룰지를 타입으로써 정의한다.

프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.

- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
  - 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 오퍼레이션을 두고 그 외는 제한함으로써 프로그래머의 실수를 막아준다.
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다
  - 타입 사용 시에 개발자가 메모리 할당을 하지 않아도 타입에 해당하는 객체를 생성 시에 메모리 확보를 하는 등의 문맥을 제공한다.

### 객체지향 패러다임 관점의 타입

프로그래밍 언어 관점에서 보면 타입은 호출 가능한 오퍼레이션의 집합을 정의하고 이는 다시 말해 객체의 퍼블릭 인터페이스를 정의하는 것이다. 또한 개념 관점에서 봤을 때 타입은 공통의 특성을 가진 객체들을 분류하는 기준인데 여기서 공통의 특성은 퍼블릭 인터페이스가 될 수 있다.

따라서 위의 두 관점을 종합하면 다음과 같은 결론이 나온다.

- 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

이러한 정의는 객체에게 중요한 것은 속성이 아니라 행동이라는 사실을 다시금 일깨워준다. **객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.**

## 2. 타입 계층

타입 사이의 포함관계타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 **슈퍼타입(supertype)**, 더 특수한 타입을 **서브타입(subtype)** 이라고 부른다.

결론적으로 말하면,

- 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
- 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.

서브타입의 인스턴스 집합은 슈퍼타입의 인스턴스 집합의 부분집합이기 때문에 더 특수한 퍼블릭 인터페이스를 가지는 객체들은 동시에 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 집합에 포함된다. 즉, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.

## 3. 서브클래싱과 서브타이핑

객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스이고 타입 계층을 구현하는 방법은 상속을 이용하는 것이다. 타입 계층을 구현할 때 지켜야 하는 제약사항을 클래스와 상속의 관점에서 살펴보자.

### 언제 상속을 사용해야 하는가?

마틴 오더스키는 다음 두 질문에 모두 '예'라고 답할 수 있는 경우에만 상속을 사용하라고 조언한다.

- 상속 관계가 is-a 관계를 모델링하는가?
  - 어휘에 대한 관점에 기반한 것으로 일반적으로 "[자식 클래스]는 [부모 클래스]다"라고 말하는 게 이상하지 않다면 상속을 사용할 **후보**로 간주할 수 있다.
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
  - 클라이언트는 부모든, 자식이든 동일한 행동을 기대하며 사용한다. 이를 부모와 자식 사이의 **행동 호환성**이라 부른다.

이 중 설계를 위해 상속을 고려할 때는 사실상 두 번째 질문에 초점을 맞춰야 한다. 첫 번째 관점은 단지 우리의 어휘적인 관점을 나타낸 것일 뿐 실제 행동은 다를 수 있기 때문이다.

#### is-a 관계

부모와 자식 클래스가 어휘적으로 is-a 관계를 만족한다 하더라도 행동이 다를 수 있어 주의해야 한다.

``` swift
class Bird {
    // Bird를 사용하는 클라이언트는 fly하기를 기대한다.
    func fly() {...}
    ...
}

class Penguin: Bird {
    // Penguin은 날 수 없지만 fly() 인터페이스를 상속받는다.
    // Bird를 사용하는 클라이언트는 fly하기를 기대하지만 Penguin은 날 수 없다.
    // 따라서 Bird와 Penguin은 행동 호환성이 없다고 할 수 있다.
    override func fly() {
        // 펭귄은 날 수 없기 때문에 비워둔다.
    }
    ...
}
```

#### 행동 호환성

행동의 호환성을 판단할 때 중요한 것은 기준이 **클라이언트의 관점**이라는 것이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있지만 그렇지 않다면 묶어서는 안 된다.

### 클라이언트의 기대에 따라 계층 분리하기

행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾기란 쉽지 않다. 문제를 해결하는 방법은 **클라이언트의 기대에 맞게 인터페이스를 분리하는 것뿐**이다. 인터페이스를 분리함으로써 변경의 영향을 가둘 수 있다.

이러한 원칙을 **인터페이스 분리 원칙(Interface Segregation Principle, ISP)**라고 부른다.

한 가지 중요한 것은 설계를 할 때 설계가 현실을 정확하게 반영하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야 한다는 것이다. 결국 자연어에 현혹되지 말고 클래스 사이에 행동에 주목하여 요구사항을 지킬 수 있도록 해야 한다.

### 서브클래싱과 서브타이핑

그래서 언제 상속을 해야 할까? 이에 대한 답을 내리기 위해서는 상속을 사용하는 두 가지 목적을 알아야 하는데 사람들은 여기에 특수한 이름을 붙였다.

- **서브클래싱(subclassing)**
  - 코드 재사용이 목적
  - 자식과 부모의 행동이 호환되지 않기 때문에 자식이 부모를 대체할 수 없음
  - **구현 상속** 또는 **클래스 상속**이라고도 부름
- **서브타이핑(subtyping)**
  - 타입 계층 구성이 목적
  - 자식과 부모의 행동이 호환되기 때문에 자식이 부모를 대체할 수 있음
  - **인터페이스 상속**이라고도 부름

서브클래싱을 이용하면 자식과 부모의 구현이 강하게 결합되어 변경을 어렵게 만든다. 때문에 상속의 목적은 서브타이핑이 되어야 하며 행동 호환성을 만족시켜야 한다.

## 4. 리스코프 치환 원칙

바바라 리스코프는 올바른 상속 관게의 특징을 정의하기 위해 **리스코프 치환 원칙(Liskov Subsititution Principle, LSP)**를 발표했다. 이를 한 마디로 정리하면 **'서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다'**는 것이다. 즉, 앞에서 논의한 행동 호환성을 말하는 것이다.

책에서 나온 `Square`와 `Rectangle`의 경우, `Square`는 `Rectangle`에서 가정하고 있는 것 외의 제약을 갖고 있기 때문에 `Rectangle`을 사용하는 클라이언트 입장에서는 `Square`을 사용할 때 동일한 행동임을 보장받을 수 없게 된다. 때문에 두 클래스 사이의 대체 가능성은 없다고 볼 수 있고 리스코프 치환 원칙을 위반한 사례라 할 수 있다.

여기서 중요한 것은 이러한 **모델 사이의 관계의 유효성이 클라이언트의 관점에서만 검증 가능하다는 것**이다. 얼핏 생각했을 때 정사각형과 직사각형 간의 관계를 떠올린다면 상속을 통합 타입 계층을 바로 떠올리겠지만 실제 클라이언트가 봤을 때는 이러한 호환성이 없는 것으로 보일 수도 있기 때문이다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다

리스코프 치환 원칙을 지킨다면 자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있게 되고 이는 기능 확장을 위해 기존 코드를 변경하지 않아도 됨을 의미한다. 따라서 자연스럽게 OCP를 만족시키게 된다.

## 5. 계약에 의한 설계와 서브타이핑

리스코프 치환 원칙과 계약에 의한 설계 사이의 관계를 다음과 같이 요약할 수 있다.

- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다.

서브타입은 이미 맺어져 있는 클라이언트와 슈퍼타입 간의 계약을 준수해야 하며 이는 슈퍼타입의 메서드를 오버라이딩 시에도 마찬가지이다.