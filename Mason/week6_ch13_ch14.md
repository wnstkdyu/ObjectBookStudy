# 13장. 서브클래싱과 서브타이핑

- 435
  - 상속의 첫 번째 용도는 **타입 계층을 구현하는 것**
    - 타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화(generalization)이고, 자식 클래스는 부모 클래스의 특수화(specialization)이다.
    - 다형적으로 동작하는 객체들의 관계에 기반한 확장과 유연성
  - 상속의 두번째 용도는 **코드 재사용**
    - 결합도 증가 조심하기

### 타입

#### 개념 관점의 타입

- 437
  - 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스(instance)라고 부른다. 일반적으로 타입의 인스턴스를 객체라고 부른다.
  - 심볼(symbol)이란 타입에 이름을 붙인 것이다.
  - 내연(intension)이란 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동.
  - 외연(extension)이란 타입에 속하는 객체들의 집합.

##### 프로그래밍 언어 관점의 타입

- 437
  - 프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.
    1. 타입에 수행될 수 있는 유요한 오퍼레이션 집합을 정의
    2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공

##### 객체지향 패러다임 관점의 타입

- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
- 프로그래밍 언어 관점에서 타입이란 **동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합**
- 438
  - 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미. 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것 > 객체가 수신할 수 있는 메시지의 집합 > **퍼블릭 인터페이스** > 타입을 정의한다 = 객체의 퍼블릭 인터페이스를 정의한다.
  - 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
  - **객체에게 중요한 것은 속성이 아니라 행동이다.**
  - 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르다면 이들은 서로 다른 타입으로 분류된다.

#### 타입 계층

##### 타입 사이의 포함관계

- 443
  - 언제 상속을 사용해야 하는가?
  - 상속 관계가 is-a관계를 모델링하는가? "자식 클래스는 부모클래스다"라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주 가능
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? 클라이언트 입장에서 두 클래스의 차이점을 몰라야 한다. 이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.
- 445
  - 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a관계를 사용하지 말아야 한다.
  - 행동 호환의 여부를 판단하는 기준은 클라이언트의 관점. > 행동
  - Bird와 Penguin 이야기... 둘은 묶기 애매쓰..
  - 개방폐쇠원칙 무시.
- 448
  - 해결방법으로 **클라이언트의 기대에 따라 계층 분리**
- 449
  - 인터페이스(프로토콜)로 클라이언트에게 보여지는 메서드 노출을 제한.
  - 결국 합성 얘기.
- 450
  - ISP : 인터페이스를 클라이언트의 기대에 따라 분리 Interface Segregation Principle.
- 451
  - **현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼자.** 
- 452
  - 서브클래싱과 서브타이핑
    - 서브클래싱 : 재사용 목적으로 상속 - 구현상속 클래스 상속
    - 서브타이핑 : 타입 계층을 구성하기 위한 상속 사용, 인터페이스 상속이라고 한다.
  - **대체가능성(Substitutability)** : 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래의 대체 가능성을 포함한다.

##### 리스코프 치환 원칙







# 14장. 일관성 있는 협력

- 470

  - 설계를 재사용
  - 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.
  - 가능하면 유사한 기능을 구현하기 유사한 협력 패턴을 사용하라.

- 488

  - 일관성 있는 설계를 위해 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해보기

- 490

  - 변경의 쥑가 서로 다른 코드가 한 클래스 안에 뭉쳐있는 것은 좋지 않다.

- 493

  - 일관성 있는 협력을 위한 지침1
    - 변하는 개념을 변하지 않는 개념으로부터 분리하라.
  - 일관성 있는 협력을 위한 지침2
    - 변하는 개념을 캡슐화하라.

- 494

  - 데이터은닉
  - 캡슐화는 데이터 은닉 이상
  - 디자인 패턴의 주제인 변화하는 개념을 캡슐화하라.
  - 캡슐화란 변하는 어떤 것이든 감추는 것
  - **변할 수 있는 것을 감춰라**

- 495

  - 자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 한다.

- 499

  - 변하지 않는 부분으로부터 변하는 부분을 분리
  - 변하는 부분의 공통점을 추상화하는 것도 잊지 않기
  - 변하지 않는 부분이 오직 추상화에만 의존하도록 관계를 제한하고 변경을 캡슐화

- 512

  - 협력의 핵심은 변경을 분리하고 캡슐화 하는 것
  - 객체들의 역할과 책임을 결정하고 결정된 협력이 코드의 구조를 결정한다.
  - 변경의 방향을 파악할 수 있는 감각을 기르기
  - **코드를 수정하지 않고도 원하는 변경을 수용할 수 있도록 협력과 코드를 리팩터링 하는 것**
  - 다음에 나오는 두 가지 개념 1.패턴 2.프레임워크

  
