# 9장. 유연한 설계

#### 개방-폐쇄 원칙

- 282
  - OCP: 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
  - 확장에 대해 열려 있다 = 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
  - 수정에 대해 닫혀 있다 = 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 283
  - 컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라
    - 런타임 의존성 : 실행시에 협력에 참여하는 객체들 사이의 관계.
    - 컴파일 타임 의존성: 드러나는 클래스들 사이의 관계.
    - 영화 예매 시스템에서 살펴보면 컴파일 타임 의존성은 추상클래스에, 런타임 의존성은 인스턴스에 의존하는 걸 볼 수 있다.
- 284
  - 추상화가 핵심이다. OCP 원칙의 핵심은 추상화에 의존하는 것 
  - '코드가 지나치게 복잡하고 어렵다면 추상화가 잘 되어있지 않다는 증거일 수도 있지 않을까?'
- 286
  - 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 한다. 추상화가 수정에 대해 닫혀 있을 수 있는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이라는 사실.

#### 생성 사용 분리

- 287
  - 객체 생성을 피할 수는 없다. 어딘가에서는 반드시 객체를 생성해야 한다. 문제는 객체 생성이 아니라 부적절한 곳에서 객체를 생성하는 것이다.
  - 객체의 생성과 사용을 분리하자. (DI의 Factory나 Container를 애기하는 건가 싶다.)
- 288
  - 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법: 객체를 생성할 책임을 `클라이언트`로 옮기는 것이다.
  - ex: Movie가 DiscountPolicy를 의존할 때 Movie의 클라이언트가 적절한 DiscountPolicy 인스턴스를 생성한 후 Movie에게 전달하게 하는 것이다.
    - why? Movie에게 금액 할인 정책을 적용할지, 비율 할인 정책을 적용할지를 알고 있는 것은 Movie와 협력할 클라이언트이기 때문.
  - 이전 Architecture에서의 클라이언트는 Consumer객체였다.

#### 팩토리 추가하기

- 289
  - 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체 __Factory__
- 291
  - FACTORY는 도메인 모델에 속하지 않는다. 팩토리를 추가한 이유는 순수하게 기술적인 결정이다.
    - (전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것)
  - 표현적 분해(도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것) 만으로 해결할 수 없다. 
    - (표현적 분해) 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제들을 갸시킨다.
  - 그래서 나온 것이 순수한 가공물(도메인과 무관한 인공적인 객체) PURE FABRICATION(순수한 가공물)
- 293
  - 의존성 주입 정의 상기 : 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법 __의존 성주입(Dependency Injection)__
  - 의존성 주입의 3가지 방법
    - constructor inejction, setter injection, method injection
- 295
  - 숨겨진 의존성은 나쁘다.
  - 의존성 주입 외에도 해결할 수 있는 방법 __Service Locator__ (사용해보셧나요? 이것도 아키텍쳐에 나오는데)
  - __Service Locator__
    - 의존성을 해결할 객체들을 보관하는 일종의 저장소
    - 외부에서 객체에게 의존성을 주입해주는 DI와 달리 SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.
    - '클라이언트에서 팩토리를 쓰는것과 비슷한 느낌.'
    - 하지만 의존성이 밖으로 드러나지 않는다.
- 304
  - 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.
  - SEPARATED INTERFACE 패턴.
- 305 유연성에 대한 조언.
  - __유연한 설계는 유연성이 필요할 때만 옳다.__
  - 유연한 설계라는 말의 이면에는 복잡한 설계라는 의미가 숨어 있다.
  - 변경은 예상이 아니라 현실이어야 한다. 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다.
  - 유연성은 복잡성을 수반한다. 유연하지 않는 설계는 단순하고 명확하다.
  - 설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. 유연함은 단순성과 명확성의 희생 위에서 자라난다.
  - 유연한 설계를 단순하고 명확하게 만드는 유일한 방법은 __사람들 간의 긴밀한 커뮤니케이션__ 뿐이다.
  - 복잡성이 필요한 이유와 합리적인 근거를 제시하지 않는다면 어느 누구도 설계를 만족스러운 해법으로 받아들이지 않는 것이다.
  - 불필요한 유연성은 복잡성을 낳는다. 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라.
  - 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 다.
  - 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설계의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만들어라.
- 306
  - 초보자가 자주 저지르는 실수 중 하나는 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에 집중하는 것이다.
- 307
  - 책임의 불균형이 심화되고 있는 상태에서 객체의 생성 책임을 지우는 것은 설계를 하부의 특정한 메커니즘에 종속적으로 만들 확률이 높다. 불필요한 싱글톤 패턴은 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 대 도입되는 경향이 있다.
  - 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다.
  - 이미 객체가 존재하는 것처럼 객체들 간의 관계를 신경 쓰는 일.
  - 요구사항을 충족시킬 수 있는 객체를 인스턴스화하는 방법에 대해 생각하는 것을 뒤로 미룰 때 위험을 최소화한 상태로 작업할 수 있다. 너무 일찍 결정하는 것은 비생산적이다.
  - __객체를 생성하는 방법을 여러분 자신이 신경 쓰기 전에 스세템에 필요한 것들(책임)을 생각하자__
  - __의존성을 관리해야하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.__





# 10장. 상속과 코드 재사용

- 308
  - 객체지향에서는 코드를 재사용하기 위해 '새로운' 코드를 추가한다. > 상속, 합성
  - 합성: 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법으로 흔히 합성어라고 부른다.
- 309
  - 코드의 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다. 코드가 비슷하다고 하지만 함께 수정할 필요가 없다면 중복이 아니다. 
  - DRY 원칙 (Don't Repeat Yourself)
- 316
  - 중복코드 줄이기
    - 타입 코드 사용하기 (클래스를 하나로 합치는 것)
      - 결국 클래스 내에 if 문이 늘어나게 된다.(분기처리)
      - 타입 코드를 사용하면 낮은 응집도와 높은 결합도라는 문제 야기.
      - 해결방법1. 상속
- 320
  - 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 쉽지 않다.
  - 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 요구한다.
  - override 안에서 super. 을 호출해야되는지 말아야되는지 결정하는건 적지 않은 비용 발생.
- 323
  - 자식 클래스는 부모클래스의 불필요한 세부사항에 엮이게 된다.
- 329
  - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
- 332
  - 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.
- 333
  - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.
  - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.
    - 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 뛰어난 결과를 얻을 수 있다.
- 343
  - 책임을 아무리 잘 분리하더라도 부모 클래스의 인스턴스 변수 추가는 자식클래스의 초기화를 어렵게 할 수 있다. 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스에 정의된 인스턴스 변수를 초기화해야하기 때문에 부모 클래스에 추가된 인스턴스변수는 자식 클래스의 초기화 로직에 영향을 미친다.
- 345
  - 객체지향에 능숙한 개발자들은 상속의 단점을 피하면서 코드를 재사용할 수 있는 더 좋은 방법이 있다는 사실을 알고 있다. 바로 __합성__ 이다.



----

### Discussion

- 한번 더 체크해서 물어보기
  - 5장에서 책임 할당 원칙 패턴으로 할당을 할 때 책임을 전문가에게 맡기라고 했었는데, 아직 구체적인 데이터 기반으로 객체를 생성하지 않고 메시지를 받아 처리할 객체를 정하라고했는데.. 다시 말하면 여기서 말한 전문가는 이미 도메인 개념을 나눌 때의 전문가를 의미하는건지?
    - 도메인 개념에서의 전문가를 찾는거 맞죠?
    - 291페이지에 어떤 책임을 할당하고 싶다면 제일 먼저 도메인 모델 안의 개념 중에서 적절한 후보가 존재하는지 찾아봐야 한다고 써있음.
- 322~
  - 그럼 상속은 언제 사용할까?