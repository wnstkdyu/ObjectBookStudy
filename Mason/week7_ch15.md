# 15장. 디자인 패턴과 프레임워크

- 513
  - 디자인 패턴: 소프트웨어 설게에서 반복적으로 발생하는 문제에 대한 반복적으로 적용할 수 있는 해결 방법, 설계를 재사용하기 위한 목적
  - 프레임 워크: 설계와 코드를 함께 재사용하기 위한 것.
  - 프레임 워크는 애플리케이션의 아키텍쳐를 구현 코드의 형태로 제공.

### 디자인 패턴과 설계 재사용

#### 소프트웨어 패턴

- 514
  - 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 515
  - 패턴이 지닌 가장 큰 가치 = 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점.
  - 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용될 수 있다. (패턴의 이름의 중요성)
    - ex) "인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임 시에 알고리즘을 바꿀 수 있게 하자." - Strategy 패턴

#### 패턴 분류

- 516
  - 아키텍쳐 패턴
  - 분석 패턴 - 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다. 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합.
  - 디자인 패턴
  - 이디엄

- 517
  - 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합 제공 - **STRATEGY 패턴**
  - 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 한다. - **BRIDGE 패턴**
  - 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공 - **OBSERVER 패턴**
  - **중요한 것은 세부적인 내용이 아닌 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실.**
  - 클라이언트가 개별 객체와 복합객체를 동일하게 취급 - **COMPOSITE 패턴**

- 518
  - TEMPLATE METHOD PATTERN (상속)
  - DECORATOR 패턴 (객체의 행동을 동적으로 추가할 수 있게 해주는 패턴)
- 521
  - **패턴은 설계의 목표가 돼서는 안된다. 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.** > 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.
- 522
  - "초심자와 전문가의 차이점은 어떤 문제를 해결하기 위해 과거의 경험을 활용할 수 있는 능력을 보유했는지 여부" - GoF의 디자인패턴에서의 저자들 중.
  - 다양한 실무 경험을 통해 어떤 컨텍스트에서 어떤 패턴을 적용해야 하는지, 그리고 이보다 더 중요한 어떤 패턴을 적용해서는 안 된는지에 대한 감각을 익히기.

#### 프레임워크와 코드 재사용

##### 코드 재사용 대 설계 재사용

- 524	
  - **프레임워크** 란 '추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계' 또는 '애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격(sekeleton)
- 526
  - 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것.
- 527
  - 그림15.8 상위 정책과 하위 정책을 별도의 패키지로 분리
- 529
  - 훌륭한 객체지향 설계는 의존성이 역전된 설계라는 점을 강조한다.
  - 의존성이 역전돼 있지 않다면, 절차적 설계를 갖는 것이다.
- 530
  - 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 완성되지 않은 채로 남겨진 동작을 훅(hook)이라고 부른다.
  - 제어역전 : 프레임워크가 작성한 코드를 언제 호출할지 제어한다. 코드를 애플리케이션 개발자가 작성하지만..
  - 개발자는 이미 특정 이름과 호출 방식이 결정된 오퍼레이션을 작성해야 하지만 결정해야 하는 설계 개념은 줄어들고 애플리케이션별로 구체적인 오퍼레이션의 구현만 남게 된다.